/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/wall.glb --output src/components/game/3d/WallModel.tsx --types 
*/

import * as THREE from 'three'
import React from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    Muro_Ladrillo_Rojo_Final: THREE.Mesh
  }
  materials: {
    Material_Inteligente: THREE.MeshStandardMaterial
  }
  animations: THREE.AnimationClip[]
}

export function Model(props: React.JSX.IntrinsicElements['group'] & { texture?: THREE.Texture }) {
  const { nodes, materials } = useGLTF('/models/wall.glb') as unknown as GLTFResult

  // Búsqueda dinámica del nodo de malla (por si cambia el nombre en Blender)
  const meshNode = nodes.Muro_Ladrillo_Rojo_Final || Object.values(nodes).find(n => n.type === 'Mesh') as THREE.Mesh;

  React.useLayoutEffect(() => {
    if (!meshNode) return;

    // Chequeo de seguridad de atributos de color
    const geometry = meshNode.geometry;
    const hasVertexColors = geometry.attributes.color || geometry.attributes.COLOR_0;

    Object.values(materials).forEach((mat) => {
      // 3. Fallback / Override: Force Stone Grey
      mat.map = null;
      mat.vertexColors = false;
      mat.color = new THREE.Color('#64748b');
      mat.roughness = 0.9;
      mat.metalness = 0.0;
      mat.emissive = new THREE.Color(0, 0, 0);
      mat.needsUpdate = true;
      mat.emissiveIntensity = 0;
      mat.needsUpdate = true;
    });

  }, [materials, meshNode, props.texture]);

  if (!meshNode) return null;

  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={meshNode.geometry}
        material={Object.values(materials)[0]} // Usar el primer material disponible
        position={[0, 1, 0]}
        castShadow
        receiveShadow
      />
    </group>
  )
}

useGLTF.preload('/models/wall.glb')
