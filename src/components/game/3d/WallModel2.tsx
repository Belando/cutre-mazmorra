/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/models/wall2.glb --output src/components/game/3d/WallModel2.tsx --types 
*/

import * as THREE from 'three'
import React from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    Bloque_1x05x2: THREE.Mesh
    Suelo_1x1_Cuadrado_Rocoso_Muy_Oscuro: THREE.Mesh
  }
  materials: {
    ['Mat_Solido_Oscuro.003']: THREE.MeshStandardMaterial
    Material_Suelo_Piedra_Muy_Oscura_Rocosa: THREE.MeshStandardMaterial
  }
  animations: THREE.AnimationClip[]
}

export function Model(props: React.JSX.IntrinsicElements['group'] & { texture?: THREE.Texture }) {
  const { nodes, materials } = useGLTF('/models/wall2.glb') as unknown as GLTFResult

  React.useLayoutEffect(() => {
    Object.values(materials).forEach((mat) => {
      mat.map = null;
      mat.vertexColors = false;
      mat.color = new THREE.Color('#64748b');
      mat.roughness = 0.9;
      mat.metalness = 0.0;
      mat.emissive = new THREE.Color(0, 0, 0);
      mat.needsUpdate = true;
    });
  }, [materials, props.texture]);

  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.Bloque_1x05x2.geometry}
        material={materials['Mat_Solido_Oscuro.003']}
        position={[0, 1, 0]}
        castShadow
        receiveShadow
      />
      {/* 
         El modelo trae su propio suelo (nodes.Suelo_1x1...), pero
         como ya tenemos un FloorModel dedicado que se renderiza bajo todos los tiles,
         podemos ocultar este para evitar z-fighting o inconsistencias,
         o dejarlo si el usuario quiere 'extra suelo'.
         Por ahora lo comento para confiar en nuestro FloorModel unificado.
       */}
      {/* <mesh geometry={nodes.Suelo_1x1_Cuadrado_Rocoso_Muy_Oscuro.geometry} material={materials.Material_Suelo_Piedra_Muy_Oscura_Rocosa} position={[0.247, 0, 0]} /> */}
    </group>
  )
}

useGLTF.preload('/models/wall2.glb')
